from pathlib import Path
from TexSoup import TexSoup
import sys

ALLOWED_CATEGORIES = {"FCM", "FCE", "PM", "PE", "SEM", "SEE", "MDM", "MDE"}
ALLOWED_TYPES = {"ICT", "ICP", "TC", "PC"}
NBA_COLS = 11

ROOT = Path(__file__).resolve().parent.parent
COURSES_DIR = ROOT / "courses"
OUT_DIR = ROOT / "outputs" / "a4"
OUT_DIR.mkdir(parents=True, exist_ok=True)


def get_scalar(soup, cmd, course):
    node = soup.find(cmd)
    if not node:
        raise ValueError(f"{course}: Missing \\{cmd}")
    return "".join(str(x) for x in node.contents).strip()


def parse_course(path: Path):
    soup = TexSoup(path.read_text(encoding="utf-8"))

    code = get_scalar(soup, "CourseCode", path.name)
    name = get_scalar(soup, "CourseName", code)
    category = get_scalar(soup, "CourseCategory", code)
    ctype = get_scalar(soup, "CourseType", code)

    if category not in ALLOWED_CATEGORIES:
        raise ValueError(f"{code}: Invalid category {category}")

    if ctype not in ALLOWED_TYPES:
        raise ValueError(f"{code}: Invalid type {ctype}")

    # ---------- Course Outcomes ----------
    outcomes_node = soup.find("CourseOutcomes")
    if not outcomes_node:
        raise ValueError(f"{code}: Missing \\CourseOutcomes")

    outcomes = []
    for item in outcomes_node.find_all("item"):
        outcomes.append("".join(str(x) for x in item.contents).strip())

    # ---------- NBA Articulation ----------
    nba_node = soup.find("CourseNBAArticulation")
    if not nba_node:
        raise ValueError(f"{code}: Missing \\CourseNBAArticulation")

    nba_rows = []
    for block in nba_node.contents:
        text = str(block).strip()
        if text.startswith("{") and text.endswith("}"):
            row = [x.strip() for x in text[1:-1].split(",")]
            nba_rows.append(row)

    if len(outcomes) != len(nba_rows):
        raise ValueError(
            f"{code}: Outcomes={len(outcomes)} NBA rows={len(nba_rows)}"
        )

    for i, row in enumerate(nba_rows, 1):
        if len(row) != NBA_COLS:
            raise ValueError(
                f"{code}: NBA row {i} has {len(row)} columns (expected {NBA_COLS})"
            )

    return code, name, outcomes, nba_rows
def generate_a4_body(courses):
    tex = []

    tex.append("% AUTO-GENERATED FILE — DO NOT EDIT")
    tex.append("% Generated by scripts/process_courses.py")
    tex.append("")

    for code, name, outcomes, nba_rows in courses:
        tex.append(r"\clearpage")
        tex.append(rf"\section*{{{code} -- {name}}}")

        # ---------- Course Outcomes ----------
        tex.append(r"\subsection*{Course Outcomes}")
        tex.append(r"\begin{itemize}")
        for co in outcomes:
            tex.append(rf"\item {co}")
        tex.append(r"\end{itemize}")

        # ---------- NBA Articulation ----------
        tex.append(r"\subsection*{NBA Articulation Matrix}")
        tex.append(r"\begin{longtable}{|c|" + "c|" * 11 + "}")
        tex.append(r"\hline")
        tex.append(
            r"CO & PO1 & PO2 & PO3 & PO4 & PO5 & PO6 & PO7 & PO8 & PO9 & PO10 & PO11 \\ \hline"
        )

        for i, row in enumerate(nba_rows, 1):
            tex.append(rf"CO{i} & {' & '.join(row)} \\ \hline")

        tex.append(r"\end{longtable}")

    out_file = OUT_DIR / "body.tex"
    out_file.write_text("\n".join(tex), encoding="utf-8")
    print(f"Generated {out_file}")

def main():
    print("Starting course processing...")

    course_files = sorted(COURSES_DIR.glob("**/*.tex"))
    print(f"Found {len(course_files)} course files")

    courses = []
    for path in course_files:
        try:
            course = parse_course(path)
            courses.append(course)
            print(f"✓ Parsed {course[0]}")
        except Exception as e:
            print(f"✗ ERROR in {path.name}: {e}")
            sys.exit(1)

    print("All courses parsed successfully.")
    generate_a4_body(courses)


if __name__ == "__main__":
    main()